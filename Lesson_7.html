<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Homework? lesson 7</title>
</head>
<body>
<script>
    /*Century From Year*/

/*The first century spans from the year 1 up to and including the year 100, The second - from the year 101 up to and
including the year 200, etc.*/

    function century(year) {

      return Math.ceil(year/100);
    }

    /*Multiple of index*/

/*Return a new array consisting of elements which are multiple of their own index in input array (length > 1).
    Some cases:
    [22, -6, 32, 82, 9, 25] =>  [-6, 32, 25]
    [68, -1, 1, -7, 10, 10] => [-1, 10]
    [-56,-85,72,-26,-14,76,-27,72,35,-21,-67,87,0,21,59,27,-92,68] => [-85, 72, 0, 68]*/

    function multipleOfIndex(array) {
      let tempArr = [];

      for(let i = 0; i < array.length; i++){

        if(array[i]%i===0){

          tempArr.push(array[i]);
        }
      }

      return tempArr;
    }

    /*Remove String Spaces*/

/*Simple, remove the spaces from the string, then return the resultant string.*/

    function noSpace(x){

     return x.split(' ').join('');
    }

    /*Remove First and Last Character*/

/*It's pretty straightforward. Your goal is to create a function that removes the first and last characters of a string.
You're given one parameter, the original string. You don't have to worry with strings with less than two characters.*/

    function removeChar(str){

      if(str.length<2) {

        return str;
      } else {
        let strToArr = str.slice(1,-1);

        return strToArr;
      }
    }

    /*Sum of Digits / Digital Root*/

/*In this kata, you must create a digital root function.
A digital root is the recursive sum of all the digits in a number. Given n, take the sum of the digits of n.
If that value has more than one digit, continue reducing in this way until a single-digit number is produced.
This is only applicable to the natural numbers.
    Here's how it works:
    digital_root(16)
    => 1 + 6
    => 7
    digital_root(942)
    => 9 + 4 + 2
    => 15 ...
    => 1 + 5
    => 6
    digital_root(132189)
    => 1 + 3 + 2 + 1 + 8 + 9
    => 24 ...
    => 2 + 4
    => 6
    digital_root(493193)
    => 4 + 9 + 3 + 1 + 9 + 3
    => 29 ...
    => 2 + 9
    => 11 ...
    => 1 + 1
    => 2*/

    function digital_root(n) {
      let temparr= n.toString().split(''); //создаю массив в который "разспличиваю" все значения/строки

      if(temparr.length===1){ //проверка на то, есть ли у числа более 2-х цифр

        return n;
      }

        while (temparr.length!==1){
          var total = 0;

          for(let i = 0; i<temparr.length; i++) {
            let digit = +temparr[i]; //с помощью унарного плюса перевожу строки-значения в числа
            total+=digit; //суммирую весь массив
          }

          temparr = total.toString().split('');//и перевожу опять в массив, который возвращается на проверку while
        }

        return total;
    }

    /*Palindrome chain length*/

/*Number is a palindrome if it is equal to the number with digits in reversed order. For example, 5, 44, 171, 4884 are
palindromes and 43, 194, 4773 are not palindromes.
Write a method palindrome_chain_length which takes a positive number and returns the number of special steps needed
to obtain a palindrome. The special step is: "reverse the digits, and add to the original number". If the resulting
number is not a palindrome, repeat the procedure with the sum until the resulting number is a palindrome.
If the input number is already a palindrome, the number of steps is 0.
Input will always be a positive integer.
For example, start with 87:
87 + 78 = 165; 165 + 561 = 726; 726 + 627 = 1353; 1353 + 3531 = 4884
4884 is a palindrome and we needed 4 steps to obtain it, so palindrome_chain_length(87) == 4*/

    var palindromeChainLength = function(n) {
        let counter = 0;
        let value = n;
        let reverseValue = Number(n.toString().split('').reverse().join(''));

        while(value!==reverseValue) {

            value+=reverseValue;
            reverseValue=+value.toString().split('').reverse().join('');
            counter++;
        }

        return counter;
    };
/*Еще один вариант решения, но он не полностью прошел валидацию*/
    /*var palindromeChainLength = function(n) {
 let counter = 0; //инициализация счетчика
        let value = n; //в последствии перезаписывающийся параметр, изначально равен N
        let reverseValue = Number(n.toString().split('').reverse().join('')); //разворот значения

          for (let i = 0; i < 10; i++) {

            if(n===10){ //значения равные 10,100,1000 никогда не станут палиндромами

              counter=undefined;
            }
            if (value !== reverseValue) {

              value += reverseValue;//перезапись параметров сравнения
              reverseValue = Number(value.toString().split('').reverse().join(''));
              counter++;//увеличение счетчика
            }
          }

        return counter;
    };*/


    /*Magic Sum of 3s*/

/*The magic sum of 3s is calculated on an array by summing up odd numbers which include the digit 3. Write a function
magic_sum which accepts an array of integers and returns the sum.
Example: [3, 12, 5, 8, 30, 13] results in 16 (3 + 13)
If the sum cannot be calculated, 0 should be returned.*/

    function magicSum(numbers) {

      if(numbers===undefined || numbers===null || numbers===[]){

        return 0;
      }
      let tempArr = [];
      for(let i = 0; i<numbers.length; i++) {

        if(numbers[i].toString().indexOf('3')!==-1 && numbers[i]%2!==0) {

          tempArr.push(numbers[i]);
        }
      }
      if(tempArr.length === 0) {
        return 0;
      } else {
        return tempArr.reduce(function (a,b) {
          return a+b;
        });
      }
    }
</script>
</body>
</html>